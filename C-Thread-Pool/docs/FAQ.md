### 为什么不使用`pthread_exit()`来退出线程？


`thread_do` 之前使用的是 `pthread_exit()`。然而这样做导致在测试内存泄漏时非常困难。原因在于当调用 `pthread_exit()` 时，并不是所有的内存都会被 pthread 释放（可能是为未来的线程保留内存或错误地认为应用程序正在终止）。正因为如此，现在采用简单的返回语句来代替。

有趣的是，使用 `pthread_exit()` 会导致更多的内存被分配。


### 为什么在调用`thpool_destroy()`之后使用`sleep()`？


这仅在测试中是必要的。原因是如果你调用了 `thpool_destroy()` 然后立即退出，程序可能会在所有线程完成释放内存之前就退出。这样一来就无法检查内存泄漏了。

在生产环境中你不必担心这个问题，因为如果你在销毁线程池后立即调用 `exit()`，线程将会由操作系统自动释放。如果你在程序执行过程中销毁线程池，这也无关紧要，因为程序不会立即退出，因此线程将有足够的时间来终止。

### 为什么 `wait()` 占用了我所有的 CPU？

注意：自 2015 年 12 月 11 日起，`wait()` 不再使用轮询。相反，使用条件变量，因此理论上不应该有任何 CPU 开销。

通常，“wait()”在调用时会将 CPU 使用率飙升至满。只要持续时间不超过 1 秒，就属于正常现象。发生这种情况的原因是“wait()”经历了轮询的各个阶段（称为智能轮询）。

 *最初轮询之间没有间隔，因此 CPU 利用率为 100%。
 *此后轮询间隔呈指数增长。
 *最后x秒后，如果仍然有工作，轮询会回落到一个非常大的间隔。

wait() 以这种方式工作的原因是，该函数主要在有人想要等待某些计算完成时使用。因此，如果假设计算需要很长时间，那么我们不想太频繁地轮询。我们仍然希望快速轮询，以防计算很简单。为了解决这两个问题，出现了这种看似尴尬的行为。
